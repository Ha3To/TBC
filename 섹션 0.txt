#컴퓨터의 구성요소

<컴퓨터 구성품>

-Main Board, Mother Board(메인보드)
ㄴ컴퓨터 모든 부품들을 연결시켜주는 부품

-Central Processing Unit (중앙 처리장치)
ㄴ컴퓨터의 뇌
ㄴ컴퓨터 부품들을 효율적으로 사용하도록 운영함

-Random Access Memory (주 기억장치)
ㄴ전원을 끄면 데이터가 사라짐
ㄴ임의접근이 가능한 메모리

-Hard Disk Drive, Solid State Drive (보조 기억장치)
ㄴ컴퓨터를 꺼도 정보가 유지됨
ㄴ주 기억장치보다 느리다는 단점
ㄴHDD는 물리적으로 빛을 이용해 정보를 읽어들임 그래서 속도의 한계가 있음
ㄴSSD는 전기신호로 정보를 읽어냄 그래서 속도가 빠름

-Graphics Processing Unit (그래픽 카드)
ㄴ그래픽스 용도의 cpu와 메모리도 들어있음

-PSU(파워)
ㄴ컴퓨터에 전기를 공급해줌

=====================================================

#컴퓨터 작동 원리

-부팅 절차(전원을 키다)
1. 전원 공급
ㄴ메인보드가 전기를 공급받음, Read Only Memory Boot Input Output System이 작동됨

2. 부트프로그램 실행

3. 하드웨어 검사

4. 운영 체제 로드
ㄴHDD나 SSD에 OS가 있음
ㄴCPU는 RAM하고만 일함(그래서 보조 기억장치에 있는걸 주기억장치로 복사해와야 CPU가 프로그램을 실행)

5. 운영 체제 실행

=====================================================

#운영체제가 해주는 일들(Operating System)

컴퓨터를 킨다 = 보조 기억장치(SSD, HDD)에 있는 OS를 주 기억장치(RAM)으로 가져와서 CPU가 실행 시키는 것

*OS의 종류
-윈도우
-리눅스
-유닉스
-맥os
-ios(모바일)
-안드로이드(모바일)

-과거에는 하드웨어를 조작하는 프로그램을 하나하나 만들었다 -> 프로그래밍 소요가 많음 -> 응용 프로그램 만들기가 힘들어짐 -> 공통적으로 개발해야하는 부분들을 묶어서 사용하자 -> OS의 시작

-OS에서 커널(Kernel)이 하드웨어를 담당함

-컴퓨터의 자원(Resource)을 관리하는 것도 OS담당
ㄴ여러개의 프로그램을 실행시킬때 효율적으로 자원을 각 프로그램에 분배해줌

-프로그램을 만들때 하드웨어적인 부분을 매번 만들필요 없이 인터페이스와 같은 도구를 제공해줌

-사실 사용자가 컴퓨터에게 내리는 모든 오더는 OS가 실행해준다.

=====================================================

#컴퓨터는 왜 2진수를 사용하는가

-컴퓨터는 다양한 정보를 '숫자'로 바꿔서 인식함
ㄴ여기서 사용하는 '숫자'는 2진수(Binary Numercial System)

-에디슨 효과 = 리처드슨 효과 = 열전자 방출
ㄴ전구의 필라멘트에 열이 오르면 음전자를 방출됨
ㄴ이때 +극을 가져다 될때 음전자가 +극으로 이동함 = 전류가 흐름

-진공관
ㄴ전자가 음극에서 양극으로 흘렀다가 막았다가 할수있음(껏다 켰다)
ㄴ히터가 캐서드를 달구면 전자가 나오고 플레이트(양극)로 전자가 이동하는데 그 사이에있는 구멍이 있는 컨트롤 그리드에 음전압을 걸거나 양전압을 걸어주면서 캐서드에서 나오는 전자를 컨트롤 할수있음
ㄴ작은 전기신호로 큰 전기신호를 제어할수있음 그래서 이 진공관들을 많이 연결시켜서 컴퓨터를 만들었기에 컴퓨터는 2진수를 사용함

-트랜지스터
ㄴ진공관과 비슷함, 크기는 훨씬 작음, 안전함

-집적 회로(Integrated Circuits)
ㄴ트랜지스터를 극한으로 소형화해서 잔뜩집어넣은 것 
ㄴ이게 이제 오늘날의 cpu같은거임

=====================================================

#현대적 컴퓨터의 기본 구조

-앨런 튜링, 폰 노이만 등 많은 엔지니어들이 '내장형 프로그램 방식'의 컴퓨터로 발전시킴 (Stored Program Computer)

-입력장치, 메모리, cpu, 출력장치 대표적인 구성요소

-오늘날은 CPU와 메모리, 입출력장치가 서로 분리

-CPU와 메모리는 서로 직접 교류하는 것이 아닌 시스템 버스를 이용하여 교류함

=====================================================

#컴퓨터 메모리의 기본 구조

-CPU와 메모리(주기억장치)는 서로 교류한다.
ㄴCPU는 메모리에서 정보를 가져와서 연산하고 그 결과를 다시 메모리로 보낸다.

-캐쉬 메모리
ㄴCPU와 메모리가 교류할때 '자주'왔다갔다하는 정보는 캐쉬메모리에 저장해서 속도를 향상시킬수있다.

-메모리에서는 데이터가 '한 줄'로 저장되어있다.

-메모리에 저장된 정보에 접근하는 방법에는 '순차 접근'과 '임의 접근'이 있다.
ㄴ각 정보들은 '셀'이라는 방에 저장되어있다.
ㄴ셀: 트랜지스터, 커패스터로 구성되어있는 정보를 저장하는 장치(1bit씩 저장됨)
ㄴ순차 접근(Sequential Access): 첫번째 정보부터 차례로 정보에 접근하는 방식(ex, 자기 테잎)
	   처음부터 마지막 정보까지 차례로 접근하기에 속도가 느림
ㄴ임의 접근(Random Access): 각 정보들의 '주소'를 기반으로 정보에 접근하는 방식(ex, RAM)
	   필요한 정보의 '주소'만 알면 바로 정보에 접근이 가능하기에 속도가 빠름

-오늘날의 CPU와 메모리가 서로 교류할때는 주소 버스, 컨트롤 버스, 데이터 버스 3가지 버스로 교류함
ㄴ임의 접근을 하기위해서 주소 버스(CPU -> 메모리 일방통행)와 데이터 버스는 분리되어있다.
ㄴ컨트롤 버스는 데이터를 줄지 받을지 결정신호가 이용하는 버스이다.

-데이터를 주고받는 과정
ㄴ컨트롤 버스(CPU: 메모리야 데이터를 나한테 보내) -> 주소 버스(CPU: 내가 찾는 데이터 주소는 여기야) -> 데이터 버스(메모리: 너가 찾는 데이터 보냈다.) -> 컨트롤 버스(CPU: 메모리야 내가 데이터 보낼게) -> 주소 버스(CPU: 이 주소에다가 데이터를 저장해) -> 데이터 버스(CPU: 데이터 보냈다.)

ㄴ이 과정 중에 자주 왕래하는 데이터는 위에서 언급한 '캐쉬 메모리'로 저장하여 속도를 향상시킴
ㄴ나중에 배울 '포인터'라는 것을 사용하기위해 '주소 버스'가 존재하는 것이다.

=====================================================

#CPU의 기본 구조

-프로그램이 실행되는 과정
ㄴ사용자로부터 입력을 OS가 받음
ㄴ보조기억장치에서 프로그램을 복사해서 주기억장치로 가져오게됨
ㄴCPU가 주기억장치에서 프로그램을 가져와서 실행함

-CPU의 언어
ㄴ기계어: 01010---으로 되어있는 2진수 언어

ㄴ어셈블리 언어: LOAD [10]  --> 이것은 '주소'을 의미함
	          ADD   [11]
	          STORE [12] 등과 같이 인간이 이해할만한 말로 바꾼 언어(니모닉)

ㄴ고수준 프로그래밍 언어: A = 3
		         B = 4
		         C = A + B와 같이 사람이 훨씬 사용하기 편한 언어

-CPU의 명령어
ㄴCPU는 의외로 적은 명령어만으로 많은 일들을 한다.
ㄴ더하기, 비교하기, 정보 입력받기, 지정된 메모리 주소로 점프, 정보 가져오기, 출력하기, 저장하기 등이 CPU명령어의 대부분이다.
ㄴ물론 기술이 발전함에따라 CPU의 명령어가 늘어나고있다.

-CPU의 구성 요소
ㄴ산술 논리 장치: 연산 장치
ㄴ제어 장치 
ㄴ다수의 레지스터: 산술 논리 장치의 작업 공간, 메모리 데이터 혹은 메모리 주소가 저장되는 장치이긴 하지만 '저장'이라는 관점에서 볼때 메모리와는 다르다는 것을 인지해야함

=====================================================

#CPU가 일하는 방법

1. 프로그램 카운터 레지스터에 프로그램의 첫번째 인스트럭션(명령어)의 주소를 넣는다.
ㄴOS가 프로그램을 읽어오면 CPU가 실행하도록 함
ㄴ프로그램 카운터는 항상 CPU가 실행시켜야할 다음 명령의 주소를 가리키고 있다.

2. 메모리 주소 레지스터로 주소를 가져간다음 그 주소의 명령어를 메모리 데이터 레스터로 가져온다.

3. 메모리 레지스터가 가져온 명령어를 명령어 레지스터로 가져간다. 이때 프로그램 카운터값이 증가한다. 왜냐 프로그램 카운터는 항상 다음에 실행시켜야하는 주소값이 들어가기 때문이다.

4. 명령어 레지스터에 있는 명령어가 제어 장치로 가서 제어 장치에의해 해당 명령이 실행됨 이를 '디코드'라고 한다.

5. 만약 명령어가 10번에 있는 데이터를 가져오는 것이라면 다시 메모리 주소 레지스터에 10을 넣어주고 10번 주소에 있는 값(3이라는 숫자라고 예를 들자)을 메모리 데이터 레지스터로 가져온다.

6. 이번에는 가져온 데이터가 명령어가 아닌 연산에 사용되는 값이기에 명령어 레지스터로 가지않고 어큐뮬레이터로 간다.
ㄴ어큐뮬레이터는 산술 논리 장치(ALU)와 밀접하게 일하지만 엄연한 레지스터임을 인지하자

7. 이제 첫번째 명령이 끝났으니 아까 다음 명령을 준비해놓은 프로그램 카운터의 주소값이 메모리 주소 레지스터로 가면서 위에서 설명한 일련의 과정을 반복한다.

=====================================================

#정보의 단위

-클라우드 샤논
ㄴ정보의 기본단위인 비트를 처음으로 만들어냄

-데이터와 정보는 다른 말
ㄴ데이터 -> 처리과정 -> 정보

-비트 Bit(binary digit): 0 또는 1 정보의 기본 단위

-바이트 Byte: 8비트, 메모리 주소의 기본 단위
ㄴ왜 8비트인가?: 컴퓨터가 발전하면서 관습적으로 굳어진 것

-16비트 워드, 32비트 워드: CPU가 데이터를 다루는 기본 단위 = 레지스터의 크기
ㄴ프로그램 다운 받을때 32비트용 64비트용 나눠져있는 이유가 컴퓨터의 CPU 레지스터의 크기가 다르기 때문

=====================================================

#2진수

-10진법의 의미
ㄴ256을 예로 들면
	256 = 200 + 50 + 6
	      = 2 * 100 + 5 * 10 + 6 * 1
	      = 2 * 10^2 + 5 * 10^1 + 6 * 10^0 이라고 표현할수있다
		ㅣ              ㅣ            ㅣ
		 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
			    ㅣ
		여기서 10은 밑(Base)을 의미한다. 그리고 그 밑이 10이기에 이를 10진법이라고 하고 왜 10이냐하면 사람은 손가락이 10개이기때문이다. 반면에 컴퓨터는 저 밑에 2를 쓰기 때문에 2진수인것이다. 왜 2냐하면 진공관의 꺼짐과 켜짐 2가지의 경우로 계산하기 때문

-2진수를 10진수로 변환
ㄴ10(2진수) = 1 * 2^1 + 0 * 2^0
	   = 2 + 0
	   = 2
   11(2진수) = 1 * 2^1 + 1 * 2^0
	   = 2 + 1
	   = 3
1011(2진수) = 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0
	   = 8 + 0 + 2 + 1
	   = 11
ㄴ위 계산과정을 보면 알수있듯 2진수의 밑은 2를 사용하고 해당 자릿수의 제곱은 2^n-1임을 알수있다.

-2진수 더하기
ㄴ2진수 더하기에서는 1과 1이 만나면 다음 자릿수에 1을 올림해주고 0이 내려온다
Ex) 10           11
  +  1        +   1
--------     --------
     11         100

-10진수를 2진수로 변환
ㄴ10진수를 2로 계속 나누고 마지막 나머지부터 역순으로 나열하면 그게 10진수를 2진수로 변환한 것이다.

Ex)                             몫             나머지
     148(10진수) / 2 =    74                0
	    74 / 2 =    37                0
	    37 / 2 =    18                1
                  18 / 2 =     9                 0
                    9 / 2 =     4                 1
                    4 / 2 =     2                 0
                    2 / 2 =     1                 0     ^
                    1 / 2 =     0                 1     ㅣ방향으로 수를 나열하면됨

		148(10) = 1001 0100(2) 이렇게 변환

-부호(signed)가 있는 정수 표현(8비트)
ㄴ'2의 보수'를 이용하여 부호를 표현한다.

Ex) -5(10)을 2진수로 바꾼다면

1. 5를 2진수로 = 0000 0101

2. 보수 취하기(complement) = 1111 1010
ㄴ보수 취하기란?: 0을 1로, 1을 0으로 값을 반전시켜준다.

3. 보수 취한것에 더하기 1하기 = '1'111 1011
			   ㄴ여기서 첫 비트가 1이면 음수 0이면 양수이다.
4. 검산하기
ㄴ2진수로 양수 5와 음수 5를 더해서 0이 나오는지 확인한다.

     0000 0101
+   1111 1011
------------------
  1 0000 0000
  ㄴ우리는 8비트 정수를 계산했기땜시 여기에서 1은 없어진다. 고로 0이 나옴

※'2의 보수'정수 표현법에서 -0과 0은 같다!

-음의 2진수 정수를 10진수로 변환

1. 1001 1110을 10진수로 변환하기
ㄴ첫 비트가 1이므로 음수임을 알수있다.

2. 보수를 취한다.
ㄴ0110 0001

3. 보수 취한거에 1을 더한다.
ㄴ0110 0010

4. 이를 10진수로 변환해준다.
ㄴ1 * 64 + 1 * 32 + 2 = 98 -> -98
			ㄴ우리는 2진수가 음수였음을 알고있으니 -부호를 붙여준다.

※위에서 연습했던 계산을 하기전에 부호가 있는 정수인지 부호가 없는 정수인지 확인 할것
ㄴEx) 1001 1110 -> 부호가 있는 정수라면 -98
	         -> 부호가 없는 정수라면 158

-8비트 정수의 범위
ㄴ부호가 있는 정수
	10000000(2) ~ 01111111(2)
	      -128(10) ~ 127(10)              = 256가지
ㄴ부호가 없는 정수
	00000000(2) ~ 11111111(2)
	          0(10) ~ 255(10)               = 256가지
=====================================================