#함수가 필요할 때

-함수가 왜 필요한가?
ㄴ 같은 기능을 여러번 작성하면 유지보수에서 불리하기때문에 함수를 이용한다.
ㄴ 함수를 사용하면 코드 수정이 수훨해진다.
ㄴ 그리고 기능을 확장해야할때 함수가 있으면 매우 깔끔해진다.

-함수를 언제 만들어야하는가?
ㄴ 시스템에서 같은 기능을 수행하는 코드가 여러번 나올때
ㄴ 추후에 변경의 여지가 있는 부분을 쉽게 고칠 수 있게 해놓을때

-프로그램을 만들때 신경써야하는 것
ㄴ 일반화라는 더 많은 경우에서 더 쉽게 정상 작동해야함
ㄴ 같은 기능이 여러번 나오면 안됨 (유지 보수가 어려워진다.)

-refactoring
ㄴ 함수를 사용하지 않는 시스템을 함수를 사용하는 시스템으로 바꾸는 것
ㄴ 똑같이 작동을하면서 이해하기쉽고 유지보수가 쉬운 코드로 바꾸는 것

☝️함수의 개수 또한 복잡하게 많으면 좋지않기에 '비슷한 기능'을하는 함수들은 매개변수에 변화를 줘서
함수를 통합하는 것도 좋다!
-> 함수의 함수

⚠️함수의 이름은 그 함수의 기능을 파악하기 쉬운 이름으로 짓는게 좋다.

===================================================================================================

#함수의 프로토타입

-블랙박스
ㄴ 블랙박스는 말 그대로 검은상자처럼 인풋과 아웃풋만 알 수 있고, 내부는 모르는 것을 의미한다.
ㄴ 복잡한 시스템에서는 함수의 종류와 사용량도 많기때문에 함수의 구체적인 기능을 다 알고있을 필요도 없고 그럴수도 없다.
ㄴ 그래서 함수에 어떤 인풋이 있고, 어떤 아웃풋이 있는지를 파악하고 원하는대로 조립하는 과정이 필요하다.

☝️그래서 함수의 인풋 아웃풋을 정하고 블랙박스의 내부를 채워나가는 방식으로 코딩을 하자

✓함수를 파악할땐 그 함수의 선언부를 확인하면 알 수 있다.

❗️함수에서는 컴파일과 링커 개념이 중요하다!

-프로토타입
ㄴ 함수를 main문보다 먼저 선언을 해놓는다.
ㄴ main문을 작성을하고, 먼저 선언해놓은 함수의 몸체를 main문 다음에 작성을 해주어도 컴파일과 링킹에 문제가 없다.
☝️많은 부분을 간단하게 작성을 한다면 [ 리턴값형 함수이름 (매개변수 자료형) ]의 형태로만 선언해주어도 상관없다.

-parameter(매개변수)
ㄴ 리턴형 함수이름 (parameter);
ㄴ 함수를 선언하는 부분에서 ()안에 들어가는 값들은 parameter로 함수 내부에서 사용되는 값들의 자료형을 의미
ㄴ 매개변수

-argument(인자)
ㄴ 함수이름(argument);
ㄴ 함수를 호출하는 부분에서 ()안에 들어가는 값들은 agument로 특정 값이 들어간다.
ㄴ 매개변수에대한 인자이다.

===================================================================================================

#함수의 자료형과 반환값

-함수의 반환 값
ㄴ 함수를 끝마치고 최종적으로 나오는 output을 의미한다
ㄴ 반환되는 값의 형태는 함수를 선언할때 사용자가 지정해놓을 수 있다.
ㄴ 함수를 선언할때 ['	반환 자료형(리턴값형)' '함수이름' (parameter)]의 형태로 만들게된다.

☝️정수형 반환 자료형(int)은 생략이 가능하다!
ㄴ 즉, 컴파일러가 함수의 반환 자료형이 없을경우에는 정수형으로 간주함을 알 수 있다.

-지역 변수(local variable)
ㄴ 해당 범위에서만 사용가능한 변수
ㄴ 변수 입장에서 자신이 포함된 가장 큰 범위의'{}'안에서만 유효하다.

※parameter를 여러개 사용하듯, 반환 값도 여러개일 수 있는데 이는 후에 배울 구조체에서 구현 가능하다.

-[return 값;]의 형태
1. return 값;
2. return (i < j) ? i : j;
3. if(i < j)
	return i;
   else
	return j;

ㄴ 위 처럼 1번의 형태뿐 아니라 return과 연산식을 같이 써주는 형식도 사용이 가능하다.

===================================================================================================

#변수의 영역과 지역 변수

-변수의 영역
ㄴ 변수가 선언된 함수안에서만 해당 변수가 유효하다.
ㄴ 이름이 같더라도 변수의 영역이 다르다면 유효하다.

-지역 변수
ㄴ 해당 영역내에서만 사용 가능한 변수를 의미한다.
ㄴ 반대로 지역 변수도 존재한다.

※printf("%p", &a)
ㄴ 변수의 a의 주소값을 출력하는 코드

===================================================================================================

#지역 변수와 스택(stack)

⚠️이번 강의에서는 기본개념을 배우고, 세세한 부분(할당된 메모리의 주소)들은 컴파일러에따라 다를 수 있음을 인지하자
ㄴ 메모리의 주소는 컴파일러에따라 메모리가 할당될때마다 바뀔수도 안바뀔수도있다. 

-스택(stack) 메모리
ㄴ 쌓는다는 개념이다.
ㄴ 프로그램이 실행되면 우리가 선언했던 변수들에게 메모리가 할당되는데 선언되는 순서대로 메모리가 할당된다.
ㄴ 여기서 메모리가 할당된 변수의 영역을 벗어나면(함수에서 나왔을때) 스택에서 해당 변수의 메모리가 없어진다.

☝️그래서 main문에서 선언되었던 변수를 다른 함수에서 접근이 가능하다!
ㄴ 스택 메모리에 main문에서 선언되었던 변수에대한 메모리는 여전히 존재하니까
ㄴ 포인터를 이용해서 '직접'접근이 가능하다!

==============================
int int_max(int i, int j)
{
    int m;
    m = i > j ? i : j;
    return m;
}

int main() {
    
    int a;
    
    a = int_max(1, 2);
    
    {
        int b;
        b = int_max(4, 5);
        
        {
            int b = 123;
        }
        
        {
            int c = 456;
        }
    }
    
    return 0;
}
==============================

1. 프로그램이 실행이되면 최소한으로 필요한 메모리가 스택에 쌓인다.			=> ㅁ
ㄴ 해당 메모리는 뭔지 모름 그래서 ㅁ로 표현했습니다.

2. main문에 변수 a가 선언되었으므로 메모리가 할당					=> a
						   			   ㅁ

3. int_max()함수로 들어가면서 m변수가 선언되었으므로 메모리가 할당			=> m
									   a
									   ㅁ

4. int_max()함수가 끝나면서 m에게 할된 메모리 회수				=> a
									   ㅁ

5. 다시 main문으로 돌아와서 b변수가 선언되었으므로 메모리 할당			=> b
									   a
									   ㅁ

6. 다시 int_max()함수로 진입하므로 m변수에대한 메모리 할당				=> m
									   b
									   a
									   ㅁ

7. int_max()함수가 끝나면서 m에게 할당된 메모리 회수				=> b
									   a
									   ㅁ

8. main문으로 돌아와서 '새로운 영역'에서 2번째 b변수가 선언되었으므로 메모리 할당		=> b
									   b
									   a
									   ㅁ

9. 해당 영역을 벗어나면서 2번째 b에게 할당된 메모리 회수				=> b
									   a
									   ㅁ

10. 다시 새로운 영역에 들어가면서 c변수가 선언되었으므로 메모리 할당			=> c
									   b
									   a
									   ㅁ

11. 해당 영역을 벗어나면서 c에게 할당된 메모리 회수					=> b
									   a
									   ㅁ

12. 1번째 b변수의 영역도 벗어나면서 1번째 b에게 할당되었던 메모리 회수			=> a
									   ㅁ

13. return하면서 main문도 끝이나면서 a와 최소 메모리 모두 회수하면서 스택에서는 아무것도 남지 않게됩니다.

☝️여기서 알수있는 것은 같은 이름의 변수라도 서로의 영역이 다르다면 '다른'변수이다.
ㄴ 실무에서는 이러한 일이 적지않으니 에러가 생기지 않도록 주의해야한다.
ㄴ 위에서도 언급했듯이 메모리 스택에만 있다면 포인터로 접근이 가능하다!

===================================================================================================

#재귀호출(Recursion)-재귀함수

-재귀함수
ㄴ 자기자신을 호출하는 함수
ㄴ 재귀함수에서는 조건부로 재귀하도록하는 기능을 넣던가 조건부로 함수를 종료하도록하는 기능을 넣어야한다.(stop condition)
ㄴ 그렇지 않으면 무한루프가 되어버리고 스택에 무리가 가서 프로그램이 강제종료된다.

☝️앞서 설명했던 스택 메모리에서 변수에대한 메모리가 할당되고 회수되었던 것처럼 프로그램도 메모리가 스택에 쌓인다.
ㄴ 그래서 스택에는 의외로 많은 것들이 쌓이고있으므로 재귀함수에서 종료하는 기능을 넣지않으면 스택에 무리가 간다.

※해당 강의 코드 기준
☝️디버거로 재귀함수가 동작하는 과정을 따라가보면 함수의 argument값이 4까지 올라갔다가, 다시 1까지 내려온다
 이는 argument값이 4였던 함수, 3이였던 함수, 2였던 함수, 1이였던 함수가 차례로 종료되면서 main문의 return까지가는 과정이다
ㄴ 이해가 어렵다면 영화 '인셉션'을 생각해보면 도움이 된다. 꿈속에 꿈, 또 그 꿈속에 꿈, 또 그 꿈속에 꿈까지 갔다가
ㄴ 가장 깊은 꿈에서 현실까지 차례로 깨어나지 않던가? 그런 것처럼 재귀함수 또한 같은 방식이다.
ㄴ 가장 깊은 함수(꿈)까지 갔다가 main문(현실)으로 돌아가는 것처럼 말이다.
ㄴ 또는 앞서 배웠던 스택의 구조 처럼 생각하면 쉽다. 스택에 쌓였다가 위에서부터 한개씩 제거되는 방식이다.

===================================================================================================

#재귀호출과 스택

*해당 강의 코드 기준
-왜 메모리의 간격이 4byte가 아닌가???
ㄴ 코드를 돌려보면 메모리간에 차이가 4byte(int 형)보다 좀더 차이가 난다
ㄴ 이유는 함수자체도 메모리를 소비하기때문이다.
ㄴ 컴퓨터에서 동작하는 모든것은 메모리를 차지한다는 점을 인지하자

⚠️같은 이름을 사용한다고해서 같은 변수가 아닌 완전히 다른 변수임을 기억하자. '동명이인' 이라고 생각하면 될듯하다.

☝️위에서 설명했던 스택 메모리에는 변수에대한 메모리만 할당되는 것이 아닌, 프로그램의 실행에대한 최소 메모리, 함수 메모리 등등
컴퓨터에서 동작하는 모든 것에대한 메모리가 할당된다는 점을 인지하자.
ㄴ 이런것을 스텍 프레임이라고 한다.

===================================================================================================

#팩토리얼(Factorial) 예제

-팩토리얼(n!)
ㄴ n * n-1 * ... * 1
ㄴ 이처럼 n에서부터 시작해서 -1씩 하면서 1까지 연속으로 곱하는 것을 팩토리얼이라고 하고 표기는 n!로 한다.

※재귀함수와 루프 두가지 형태로 팩토리얼 구현해볼것

-루프 형태
--------------------------
※ n = 5

for (ans = 1; n > 1; n--)
        ans *= n;
--------------------------
ㄴ 반복문 형태는 우리가 익숙한 방식으로 계산이 진행된다.
ㄴ 5 * 4 * 3 * 2 * 1을 우리가 평소 계산하는 순서(좌에서 우)에 따라서 계산한다.


-재귀 형태
----------------------------------------
※ n = 5

long recursion_factorial(int n)
{
    if (n > 0)
    {
       return n * recursion_factorial(n - 1);   // tail(end) recursion
    }
    else
        return 1;
}
----------------------------------------
ㄴ 루프 형태와는 다르게 재귀형태에서는 루프의 반대로 계산한다
ㄴ 5 * 4 * 3 * 2 * 1를 우에서 좌로 계산한다.
ㄴ 재귀함수의 특성으로 자신이 호출가능한만큼 함수를 다 호출하고 '되돌아오면서'계산을 진행하는 방식이다.

☝️재귀함수에서 return에서 재귀함수를 호출하는 것을 'tail(end) recursion'이라고 한다.

===================================================================================================

#이진수 변환 예제

-이진수 변환
ㄴ 10진수를 2진수로 변환하는 방법은 10을 2로 계속 나눠주다보면 나머지들이 생긴다.
ㄴ 이 나머지들을 역순으로 나열하면 2진수로 표현한 10이 된다.

-루프 형태로 구현
ㄴ 기본적인 방식은 재귀와 같다.
ㄴ n / 2와 n % 2를 사용해서 몫은 계속해서 다음 나눗셈으로 이어지도록 n에게 대입해주고, 나머지는 출력하는 방식이다.
ㄴ 루프 형태에서의 문제는 출력이 역순으로 나온다는 것이다.
ㄴ 그래서 나머지 나눗셈의 결과값을 배열에 넣고 그 배열을 역순으로 출력해야 우리가 원하는 결과를 얻을수있다.

⚠️이번 강의에서는 루프형태와 재귀형태의 차이점을 알아보는 것이 주요하니, 루프형태의 결과값을 역순으로 출력해보는 기능을
구현하는 것은 배열을 배우고나서 해보자

-재귀 형태로 구현
ㄴ 위 루프에서 사용한 방식을 사용한다.
ㄴ n / 2의 값은 다음 함수로 보내주고, n % 2는 출력한다.
ㄴ 재귀 함수는 이전 강의에서도 설명했듯이 '되돌아온다'라는 특성을 이용하면 역순으로 출력되던 루프의 문제점을 보완할 수 있다.


		<루프 형태>			|			<재귀 형태>
						|
void print_binary_loop(unsigned long n)		|	void print_binary(unsigned long n)
{						|	{
    while(1)					|		if(n != 0)
    {						|		{
        int quo = n / 2;			|		    print_binary(n / 2);
        int remain = n % 2;			|		    printf("%d", n % 2);
        					|		}
        printf("%d", remain);			|	}
        					|
        n = quo;				|
        					|
        if (n == 0)				|
            break;				|
    }						|
    printf("\n");				|
}						|

ㄴ 루프 형태는 결과값이 역순으로 출력된다.				ㄴ 재귀 형태는 되돌아오면서 출력하는 기능이 실행되기때문에
							  정상적인 순서로 출력된다.

===================================================================================================

#피보나치 예제와 재귀 호출의 장단점

-피보나치 수열
ㄴ 피보나치 수열은 다음과 같다. 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...
ㄴ 자신은 앞순번 2개의 수의 합과 같다.
ㄴ n번째 수 = (n - 1)번째 수 + (n - 2)번째 수

이걸 재귀함수로 구현해보면

-------------------------------------------------
int fibonacci(int number)
{
    if(number > 2)
        return (fibonacci(number - 1) + fibonacci(number - 2)); // double recursion
    else
        return 1;
}
-------------------------------------------------
ㄴ 이렇게 간단하게 구현이 가능하다.
ㄴ double recursion이된것을 알수있다.

-재귀함수의 장점
 1. 수학적인 기능을 간결하게 구현 가능하다.
 ㄴ 꽤나 큰 장점

-재귀함수의 단점
 1. 메모리를 많이 사용한다. -> 메모리 스택에 중복된 변수, 함수 등 많이 쌓임
 2. 계산에 중복이 생긴다.  -> 기존에 이미 계산된 값을 재활용을 못한다.
 ☝️ 1, 2번 때문에 필요이상의 메모리를 할당받음
 그래서 이후에 배우는 배열을 이용해서 이러한 문제점을 보완 가능하다.

⚠️ 코드가 간결해질수록 메모리 낭비와 계산 중복 등 리소스 사용량이 늘어난다.

===================================================================================================

#헤더 파일 만드는 방법

-