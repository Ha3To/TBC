#함수가 필요할 때

-함수가 왜 필요한가?
ㄴ 같은 기능을 여러번 작성하면 유지보수에서 불리하기때문에 함수를 이용한다.
ㄴ 함수를 사용하면 코드 수정이 수훨해진다.
ㄴ 그리고 기능을 확장해야할때 함수가 있으면 매우 깔끔해진다.

-함수를 언제 만들어야하는가?
ㄴ 시스템에서 같은 기능을 수행하는 코드가 여러번 나올때
ㄴ 추후에 변경의 여지가 있는 부분을 쉽게 고칠 수 있게 해놓을때

-프로그램을 만들때 신경써야하는 것
ㄴ 일반화라는 더 많은 경우에서 더 쉽게 정상 작동해야함
ㄴ 같은 기능이 여러번 나오면 안됨 (유지 보수가 어려워진다.)

-refactoring
ㄴ 함수를 사용하지 않는 시스템을 함수를 사용하는 시스템으로 바꾸는 것
ㄴ 똑같이 작동을하면서 이해하기쉽고 유지보수가 쉬운 코드로 바꾸는 것

☝️함수의 개수 또한 복잡하게 많으면 좋지않기에 '비슷한 기능'을하는 함수들은 매개변수에 변화를 줘서
함수를 통합하는 것도 좋다!
-> 함수의 함수

⚠️함수의 이름은 그 함수의 기능을 파악하기 쉬운 이름으로 짓는게 좋다.

===================================================================================================

#함수의 프로토타입

-블랙박스
ㄴ 블랙박스는 말 그대로 검은상자처럼 인풋과 아웃풋만 알 수 있고, 내부는 모르는 것을 의미한다.
ㄴ 복잡한 시스템에서는 함수의 종류와 사용량도 많기때문에 함수의 구체적인 기능을 다 알고있을 필요도 없고 그럴수도 없다.
ㄴ 그래서 함수에 어떤 인풋이 있고, 어떤 아웃풋이 있는지를 파악하고 원하는대로 조립하는 과정이 필요하다.

☝️그래서 함수의 인풋 아웃풋을 정하고 블랙박스의 내부를 채워나가는 방식으로 코딩을 하자

✓함수를 파악할땐 그 함수의 선언부를 확인하면 알 수 있다.

❗️함수에서는 컴파일과 링커 개념이 중요하다!

-프로토타입
ㄴ 함수를 main문보다 먼저 선언을 해놓는다.
ㄴ main문을 작성을하고, 먼저 선언해놓은 함수의 몸체를 main문 다음에 작성을 해주어도 컴파일과 링킹에 문제가 없다.
☝️많은 부분을 간단하게 작성을 한다면 [ 리턴값형 함수이름 (매개변수 자료형) ]의 형태로만 선언해주어도 상관없다.

-parameter(매개변수)
ㄴ 리턴형 함수이름 (parameter);
ㄴ 함수를 선언하는 부분에서 ()안에 들어가는 값들은 parameter로 함수 내부에서 사용되는 값들의 자료형을 의미
ㄴ 매개변수

-argument(인자)
ㄴ 함수이름(argument);
ㄴ 함수를 호출하는 부분에서 ()안에 들어가는 값들은 agument로 특정 값이 들어간다.
ㄴ 매개변수에대한 인자이다.

===================================================================================================

#함수의 자료형과 반환값

-함수의 반환 값
ㄴ 함수를 끝마치고 최종적으로 나오는 output을 의미한다
ㄴ 반환되는 값의 형태는 함수를 선언할때 사용자가 지정해놓을 수 있다.
ㄴ 함수를 선언할때 ['	반환 자료형(리턴값형)' '함수이름' (parameter)]의 형태로 만들게된다.

☝️정수형 반환 자료형(int)은 생략이 가능하다!
ㄴ 즉, 컴파일러가 함수의 반환 자료형이 없을경우에는 정수형으로 간주함을 알 수 있다.

-지역 변수(local variable)
ㄴ 해당 범위에서만 사용가능한 변수
ㄴ 변수 입장에서 자신이 포함된 가장 큰 범위의'{}'안에서만 유효하다.

※parameter를 여러개 사용하듯, 반환 값도 여러개일 수 있는데 이는 후에 배울 구조체에서 구현 가능하다.

-[return 값;]의 형태
1. return 값;
2. return (i < j) ? i : j;
3. if(i < j)
	return i;
   else
	return j;

ㄴ 위 처럼 1번의 형태뿐 아니라 return과 연산식을 같이 써주는 형식도 사용이 가능하다.

===================================================================================================

#변수의 영역과 지역 변수

-변수의 영역
ㄴ 변수가 선언된 함수안에서만 해당 변수가 유효하다.
ㄴ 이름이 같더라도 변수의 영역이 다르다면 유효하다.

-지역 변수
ㄴ 해당 영역내에서만 사용 가능한 변수를 의미한다.
ㄴ 반대로 지역 변수도 존재한다.

※printf("%p", &a)
ㄴ 변수의 a의 주소값을 출력하는 코드

===================================================================================================

#지역 변수와 스택(stack)

⚠️이번 강의에서는 기본개념을 배우고, 세세한 부분(할당된 메모리의 주소)들은 컴파일러에따라 다를 수 있음을 인지하자
ㄴ 메모리의 주소는 컴파일러에따라 메모리가 할당될때마다 바뀔수도 안바뀔수도있다. 

-스택(stack) 메모리
ㄴ 쌓는다는 개념이다.
ㄴ 프로그램이 실행되면 우리가 선언했던 변수들에게 메모리가 할당되는데 선언되는 순서대로 메모리가 할당된다.
ㄴ 여기서 메모리가 할당된 변수의 영역을 벗어나면(함수에서 나왔을때) 스택에서 해당 변수의 메모리가 없어진다.

☝️그래서 main문에서 선언되었던 변수를 다른 함수에서 접근이 가능하다!
ㄴ 스택 메모리에 main문에서 선언되었던 변수에대한 메모리는 여전히 존재하니까
ㄴ 포인터를 이용해서 '직접'접근이 가능하다!

==============================
int int_max(int i, int j)
{
    int m;
    m = i > j ? i : j;
    return m;
}

int main() {
    
    int a;
    
    a = int_max(1, 2);
    
    {
        int b;
        b = int_max(4, 5);
        
        {
            int b = 123;
        }
        
        {
            int c = 456;
        }
    }
    
    return 0;
}
==============================

1. 프로그램이 실행이되면 최소한으로 필요한 메모리가 스택에 쌓인다.			=> ㅁ
ㄴ 해당 메모리는 뭔지 모름 그래서 ㅁ로 표현했습니다.

2. main문에 변수 a가 선언되었으므로 메모리가 할당					=> a
						   			   ㅁ

3. int_max()함수로 들어가면서 m변수가 선언되었으므로 메모리가 할당			=> m
									   a
									   ㅁ

4. int_max()함수가 끝나면서 m에게 할된 메모리 회수				=> a
									   ㅁ

5. 다시 main문으로 돌아와서 b변수가 선언되었으므로 메모리 할당			=> b
									   a
									   ㅁ

6. 다시 int_max()함수로 진입하므로 m변수에대한 메모리 할당				=> m
									   b
									   a
									   ㅁ

7. int_max()함수가 끝나면서 m에게 할당된 메모리 회수				=> b
									   a
									   ㅁ

8. main문으로 돌아와서 '새로운 영역'에서 2번째 b변수가 선언되었으므로 메모리 할당		=> b
									   b
									   a
									   ㅁ

9. 해당 영역을 벗어나면서 2번째 b에게 할당된 메모리 회수				=> b
									   a
									   ㅁ

10. 다시 새로운 영역에 들어가면서 c변수가 선언되었으므로 메모리 할당			=> c
									   b
									   a
									   ㅁ

11. 해당 영역을 벗어나면서 c에게 할당된 메모리 회수					=> b
									   a
									   ㅁ

12. 1번째 b변수의 영역도 벗어나면서 1번째 b에게 할당되었던 메모리 회수			=> a
									   ㅁ

13. return하면서 main문도 끝이나면서 a와 최소 메모리 모두 회수하면서 스택에서는 아무것도 남지 않게됩니다.

☝️여기서 알수있는 것은 같은 이름의 변수라도 서로의 영역이 다르다면 '다른'변수이다.
ㄴ 실무에서는 이러한 일이 적지않으니 에러가 생기지 않도록 주의해야한다.
ㄴ 위에서도 언급했듯이 메모리 스택에만 있다면 포인터로 접근이 가능하다!

===================================================================================================

#재귀호출(Recursion)-재귀함수

-재귀함수
ㄴ 자기자신을 호출하는 함수
ㄴ 재귀함수에서는 조건부로 재귀하도록하는 기능을 넣던가 조건부로 함수를 종료하도록하는 기능을 넣어야한다.(stop condition)
ㄴ 그렇지 않으면 무한루프가 되어버리고 스택에 무리가 가서 프로그램이 강제종료된다.

☝️앞서 설명했던 스택 메모리에서 변수에대한 메모리가 할당되고 회수되었던 것처럼 프로그램도 메모리가 스택에 쌓인다.
ㄴ 그래서 스택에는 의외로 많은 것들이 쌓이고있으므로 재귀함수에서 종료하는 기능을 넣지않으면 스택에 무리가 간다.

※해당 강의 코드 기준
☝️디버거로 재귀함수가 동작하는 과정을 따라가보면 함수의 argument값이 4까지 올라갔다가, 다시 1까지 내려온다
 이는 argument값이 4였던 함수, 3이였던 함수, 2였던 함수, 1이였던 함수가 차례로 종료되면서 main문의 return까지가는 과정이다
ㄴ 이해가 어렵다면 영화 '인셉션'을 생각해보면 도움이 된다. 꿈속에 꿈, 또 그 꿈속에 꿈, 또 그 꿈속에 꿈까지 갔다가
ㄴ 가장 깊은 꿈에서 현실까지 차례로 깨어나지 않던가? 그런 것처럼 재귀함수 또한 같은 방식이다.
ㄴ 가장 깊은 함수(꿈)까지 갔다가 main문(현실)으로 돌아가는 것처럼 말이다.
ㄴ 또는 앞서 배웠던 스택의 구조 처럼 생각하면 쉽다. 스택에 쌓였다가 위에서부터 한개씩 제거되는 방식이다.

===================================================================================================

#재귀호출과 스택

-