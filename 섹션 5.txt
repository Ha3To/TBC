❗️섹션 5부터 공부환경이 mac으로 바뀌었습니다. 따라서 VS에서 VScode에서 코드들을 작성 및 실행하였습니다.❗️

#반복 Loop와의 만남

-goto
ㄴ goto문은 코드에서 어느 지점을 정해주면 그 지점으로 되돌아가면서 코드를 반복해서 실행한다. goto문만 작성해서 프로그램을 돌리면 무한히 반복되면 특정 조건을 만족시키면 반복문을 종료하도록 코드를 짜야한다.

-if
ㄴ 이것의 글자 그래도 ‘만약에’라는 조건을 걸수있는 명령어이다. goto문에서 if문과 goto문을 사용하여 조건이 성립되면 다른 지점으로 가도록(반복문을 탈출하는) 유도한다.

⚠️하지만 goto문은 코드를 너무 난잡하게 만들어버리기때문에(코드의 위아래를 왔다리 갔다리한다.) 불편해서 지금은 거의 사용하지않습니다.

-while
ㄴ이녀석은 ‘~하는 동안에’라는 의미를 가진 반복문 + 조건문형태의 기능을 수행한다. 위에서 설명했던 goto와 if가 짬뽕된것이다.
ㄴ while(조건) 이렇게 작성가능하며 조건이 성립될때까지 반복문은 계속 반복된다.

⚠️ 다만 주의점은 조건에 사용될 변수는 선언 및 초기화를 앞서서 해야하며, 반복문안에서 변수가 변해야함 그래야 원하는 반복문을 만들수있고 무한루프에 빠지지 않을수있다

===================================================================================================

#대입 연산자들과 기능들

-기본 연산자
	1.	‘=‘ : 대입 연산자(=를 기준으로 좌우가 같다는 의미가아닌 값을 ‘대입’하는 연산자임을 인지하자!)
	2.	‘+’ = 더하기
	3.	‘-‘ = 빼기
	4.	‘*’ = 곱하기
	5.	‘/‘ = 나누기

-연산자, 피연산자
ㄴ대입 연산자(=)를 기준으로 좌우측에 있는 변수와 값이 피연산자이다.

-Data Object

int i; -> Data Object: 어떤 데이터가 메모리안에 존재하고있을때 그 데이터를 Data Object라고함

i = 1024;
//1024 = i

i = i + 1;
—————
-L-value(object locator value), R-value(value of an expression)
ㄴ보통은 대입연산자를 기준으로 좌측에있으면 L-value, 우측에있으면 R-value라고한다.
ㄴ정확히는 메모리를 차지하고있는 특정 데이터 객체를 L-value 
ㄴ수정가능한 L-value에게 대입될수있지만, 자기 자신은 L-value가 될 수 없는 것들은 R-value라고 합니다.

⚠️ L-value는 임시적으로 R-value역할을 할수있습니다.
즉, Data Object는 L-value가 될수있다는 것이다.

const int TWO = 2; ————> 수정이 불가능한(const) L-value(여기서 ’=‘ 는 대입이아닌 초기화)

int a; ————> a,b,c는 수정가능한 L-value
int b;
int c;

a = 42; ———> 42는 R-value
b = a;
c = TWO * (a + b); ———> (a + b)는 R-value(프로그램이 계산하는 임시값, 연산이 끝나면 사라짐)

메모리 공간을 할당받았는지 아닌지, 상수인지 변수인지에 따라 L-value R-value가 구분됩니다.

===================================================================================================

#더하기(Addtion), 빼기(Subtraction), 부호(Sign) 연산자

-이항 연산자(Binary operator)
ㄴ항이 2개가 필요한 연산자
ㄴ 3 - 2에서 3과 2는 피연산자이고 값이 1이다

-단항 연산자(Unart operator)
ㄴ항이 1개가 필요한 연산자
ㄴ -16처럼 피연산자가 1개
ㄴ '-'도 엄연히 연산자이다.

❗️용어에 익숙해지자!

===================================================================================================

#곱하기 연산자

-복리 계산기
ㄴ 복리는 원금에대한 이자를 원금에 더하고 늘어난 원금에대한 이자를 또 원금에 더하는 방식이다.
ㄴ 계산식은 원금 + (원금 * 복리율) 되시겠다.

-복리 계산기를 만들기위해 필요한 변수
1. 원금
2. 복리율
3. 목표 금액
4. 목표달성까지 걸리는 시간(년)

 각각의 변수들을 사용자로부터 '입력'받고, 입력받은 값을 복리 계산식으로 계산, 계산사이클 1번당 +1년, 각 계산마다 결과값 출력
최종적으로 걸리는 시간을 출력해주는 코드를 짜보자!

✓그래프 만들기
ㄴ 코드를 실행시켜서 쭉 나열된 값들을 전부다 복사해서 엑셀에 붙여넣는다, 엑셀에서 값들이 적힌 행 또는 열을 클릭하고 삽입 -> 차트를 하면 간단한 그래프를 그려준다!

===================================================================================================

#나누기 연산자

- '/'
ㄴ 몫 나누기 연산자이다.
ㄴ 딱떨어지는 나눗셈이면 정확한 결과값을 얻을 수 있지만, 나머지가 있는 나눗셈의 경우 몫만 사용자에게 돌려준다.
ex) 14 / 7 = 2, 7 / 2 = 3(나머지 1은 truncation(절삭) 해버린다.)
이렇게 절삭을 해버리는 이유는 나머지를 표현하려면 소수로 표현되는데 정수형 나눗셈에서는 소수점을 표현할 수 없기 때문이다.

☝️짧막한 지식! : C99표준 이전에는 컴파일러에따라서 나눗셈에대한 결과값을 반올림을해서 주는데 그 값이 제각각이였다.
ㄴ 예시로 나눗셈의 결과가 2.5라고하면 2로 결과값을 돌려주거나, 3으로 돌려주는 등의 컴파일러별로 차이가있었다.
ㄴ C99 표준부터 0에 가까운쪽으로 절삭하는 것으로 정해졌다.

-실수 나눗셈
ㄴ실수와 실수로 나눗셈을하면 정수나눗셈에서는 표현이 안되었던 소수부분이 표현이된다.
ㄴ다만, 주의점이 있는데 소수와 정수로 나눗셈을 진행하면 서로의 타입이 달라서 연산을 할 수 없다.
ㄴ하지만 컴파일러가 소수와 정수 둘다 double형으로 형변환을 시켜서 결과값을 보여준다.
ex) 9.0(float) / 4.0(float) = 2.250000, 9.0(float) / 4(int) = 2.250000
ㄴ 물론 같은 결과값을 보여주지만 가급적이면 연산을 진행할때는 피연산자들의 형태를 통일해주는 방향으로 진행하자!
ㄴ 하지만 부득이한 경우 이후에 배우게될 형변환을 이용하자

===================================================================================================

#연산자 우선순위와 표현식 트리

-우선순위

	[연산자]		[결합법칙]

1.	  ()	      왼쪽에서 오른쪽
2.      +, -(단항)      오른쪽에서 왼쪽
3.	  *,/	      왼쪽에서 오른쪽
4.      +, -(이항)      왼쪽에서 오른쪽
5.	   =	      오른쪽에서 왼쪽

ex) int a, b;
a = b = -(1 + 2) * 3 + (4 + 5 * (6 + 7));
a = b = -3 * 3 + (4 + 5 * (6 + 7));
a = b = -3 * 3 + (4 + 5 * 13);
a = b = -3 * 3 + (4 + 65);
a = b = -3 * 3 + 69;
a = b = -9 + 69;
a = b = 60;

⚠️ 우리가 수학시간에 배운 '()'와 연산자로서의 '()'는 다르다!
ㄴ 물론 수식에서 ()의 역할은 우리가 알고있는 먼저 계산한다는 것은 맞지만
연산자로서의 ()는 함수에 붙는 ()를 의미함 [main() <--- 이런거]

⚠️ 같은 +, - 라도 단항인지 이항인지에 따라서 우선순위가 다르니 유의하자!

===================================================================================================

💻 이제부터 'xcode'로 코딩환경이 변경되었습니다.

#나머지 연산자

- %
ㄴ 이 연산자는 나머지값을 돌려주는 연산자이다.

ex)
int a = 13 % 5;
int b = 90 % 60; 이렇게 사용하면된다.
값은 3과 30이 각각의 값으로 들어갈것이다.

⚠️ 형식 지정자에서 쓰이던 %와 같은 기호이지만 역할은 다르니 혼동하지말자!

-초를 입력받아서 시, 분, 초로 변환해서 출력해보자!
ㄴ 코드 참조

-음수 나누기
ㄴ음수와 음수, 음수와 양수 나누기를 할때 결과값은 음수일까 아님 양수일까?
ㄴ '몫'   나누기에서는 '양측'에있는 피연산자의 부호가 같으면 양수, 다르면 음수
ㄴ'나머지' 나누기에서는 '좌측'에있는 피연산자의 부호를 따라간다.

ex)
1. 11 / 5 = 2, 11 % 5 = 1
2. 11 / -5 = 2, 11 % -5 = 1
3. -11 / -5 = 2, -11 % -5 = -1
4. -11 / 5 = -2, -11 % 5 = -1

===================================================================================================

#증가,감소 연산자

-증가 연산자
ㄴ ++를 변수의 앞 혹은 뒤에 붙여서 사용한다.
ㄴ a++, ++a이런식으로 사용하고 변수뒤에 붙이는것은 후위연산자(postfix), 앞에 붙이는것을 전위연산자(prefix) 라고한다.
ㄴ 위의 의미는 a = a + 1; or a += 1; 이다.
ㄴ ++를 앞에 혹은 뒤에붙이는것에대한 차이는 1를 먼저 더하고 연산을 하느냐 연산을 하고 더하냐의 차이이다.

ex)
int count = 0;				int count = 0;
while (count++ < 10)			while (++count < 10)
{					{
	printf("%d ", count);			printf("%d ", count);
}					}
결과또한 차이나는데 후위연산은 1부터 10까지 출력되지만 전위연산은 1부터 9까지만 출력된다.
while의 조건을 검사하는 절차에서 count에 1을 먼저더하고 조건을 검사 혹은 조건을 먼저 검사하고 count에 1을 더하는지의 차이다.

-감소 연산자
ㄴ --를 증가 연산자처럼 사용하면된다.
ㄴ 내용은 증가 연산자와 동일하다.

⚠️전위 증감 연산자는 곱하기 나누기보다도 연산우선순위가 높다!
  그리고 당연하지만 상수에는 사용할 수 없다, 변수에만 사용가능하다.

❗️증감연산자는 한 문장에서 여러번 사용하는것을 지양하자!

===================================================================================================

#표현식(Expression)과 문장(statements)

-;을 문장 마지막에 붙이는 이유
ㄴ ;는 컴퓨터에게 마침표와같은 역할을 한다.
ㄴ ;을 인식하면 그 전까지 인식되었던것들을 연산하고 실행한다.

☝️while(조건)에서는 ;이 없어도 되는이유가 '(조건)'이 부분이 완전한 문장이기 때문이다.

===================================================================================================

#순서도(Flowchart)

-순서도
ㄴ 순서도는 프로그램의 흐름을 가시화할때 많이 사용한다.
ㄴ 정해진 도형을 가지고 위에서 아래로 프로그램의 흐름을 표현한다.

ex)
int i = 0;
while (i < 10)
{
	i++;
	printf("%d\n", i);
}

위 코드를 순서도로 표현해보자!

===================================================================================================

#자료형 변환(Type Conversion)

-promotion(승격)
ㄴ 작은 자료형의 값을 비교적 큰 자료형으로 옮겨주면서 형변환을 prmotion이라고 한다.

-demotion(강등)
ㄴ 큰 자료형의 값을 비교적 작은 자료형으로 넣으려 시도하는 것을 demotion이라고 한다.
ㄴ 작은 자료형에서도 감당가능한 크기의 값이면 상관없지만 보통은 그렇지않기때문에 truncation(절삭) 이슈가 뜬다.

-ranking
ㄴ 자료형에는 ranking 시스템이 있다.

ㄴ long double > double > float
ㄴ unsigned long long, long long
ㄴ unsigned long, long
ㄴ unsigned, int
ㄴ short int, unsigned short int
ㄴ signed char, char, unsigned char
ㄴ _Bool

이런 순서로 자료형의 랭킹이 정해져있고, 정수형보다 실수형이 랭킹이 더 높다.

float와 double형을 연산하려하면 내부적으로 float형을 double로 형변환을 시켜서 연산을 한다.
ㄴ다른 자료형과 연산을 할수없기 때문이다.
그래서 float와 double형의 계산값을 float형 변수에 넣을수없다.

casting operators를 사용해서 작성자가 미리 어떤 자료형으로 변환시켰는지 쓰는것이 바람직하다!.

✓형변환을 사용할때는 항상 주의를 기울여야한다. 작은 형에서 큰 자료형으로 변환되는 것은 비교적 괜찮지만 큰 자료형에서 작은 자료형으로 형변환이 이뤄질때는 예기치못한 trucation이 발생하여 엉뚱한 값이 나올수있거나 프로그램이 망가질수있기에 조심하자!

===================================================================================================

#함수의 인수(Arguments)와 매개변수(Parameters)

-인수(Arguments)
ㄴ actual argument, actual parameter -> argument (values)

-매개변수(Parmeters)
ㄴ formal argument, formal parameter -> parameter (variables)

===================================================================================================