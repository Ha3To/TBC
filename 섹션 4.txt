#문자열

-배열
ㄴ같은 데이터 타입의 공간을 여러개 확보하는 것

ex) char fruit_name[40];
ㄴ이렇게 배열을 선언하면 된다. char(1byte)형태의 저장공간을 40개 배정받는다는 것
ㄴ자료형 변수명 [숫자] 순으로 코드를 작성하면 된다.

-%s
ㄴ이것은 string(문자열)의 형식 지정자이다.
ㄴ예를 들어 사용자로부터 문자열을 입력받는다고 가정해보면

ex) scanf("%s", fruit_name); 이렇게 사용할수있다.
ㄴ물론 fruit_name은 배열로 먼저 선언되어있어야한다.

※문자열 형식 지정자를 사용할때는 &를 사용하지 않는다.
왜냐하면 &는 메모리 주소에 접근하기위해 필요한것인데 배열선언
을 하는 부분(char fruit_name[40];)에서 fruit_name이 곧 배열을 대표하는 '맨앞주소'이기때문에 scanf에서 따로 주소에 접근하게 해주는 &를 붙일
필요가 없다.

=========================================

#sizeof 연산자

-sizeof
ㄴ할당된 메모리의 크기를 알려주는 연산자
*함수처럼 생각할수있지만 연산자이다.

sizeof a;    -> ()없이 변수명만 넣어서 사용
sizeof(int); -> 변수의 자료형을 넣어서 사용
sizeof(a);   -> ()안에 변수명을 넣어서 사용

ㄴ3가지 전부 사용가능 보통은 2번째 혹은 3번째 형태 사용

-size_t
ㄴunsigned int랑 같은 것
ㄴ다만 다른 시스템에서 sizeof를 사용했을때 나오는 값이 unsigned int가 아닐수도 있기에 이식성을 높은 size_t를 사용
ㄴ이런 이식성이 용이한 type들을 portable type이라고 함

-int *int_ptr = NULL
ㄴ이건 '포인터'라고 하는 것
ㄴ동적할당에서 사용함 이건 이후에 자세히 다룰것
ㄴint int_arr[30]과 같은 배열 선언은 이미 메모리 주소까지 다 만들어진 상황인데
ㄴint *int_ptr은 주소를 적을 종이만 준비해놓은 상태이다.
ㄴint_ptr = (int*)malloc(sizeof(int) * 30); 처럼 OS한테 이만큼의 메모리를 배정해달라고 함

※malloc = memory allocation
ㄴ이걸 사용하려면 stdlib.h 헤더파일 include해줘야합니다.

*그래서 int_arr를 sizeof해서 출력하면 120가 나오고, int_ptr를 sizeof해서 출력하면 4만 나온다. 왜냐하면 int_arr는 이미 메모리들을 다 할당받은 상태이고, int_ptr는 주소를 받을 공간만 가지고 있기때문 이것이 정적 할당과 동적 할당의 차이

*즉, int_arr는 처음부터 그냥 메모리공간을 다 할당받은것이고, int_ptr는 필요한 만큼만 메모리공간을 할당해주는 것 그렇기에 메모리에 암것도 안넣으면 int_ptr의 sizeof는 4가 나오는 것

-char string[숫자]
ㄴ이건 문자열을 저장하기위한 string배열 선언이다
ㄴ근데 문자열을 저장할때 c언어에서는 항상 마지막에 null값을 넣어야해서 n-1개의 문자를 배열에 저장할수있다. 추후 자세히 설명

=========================================

#문자열이 메모리에 저장되는 구조

-문자열 저장
ㄴ기본 데이터 타입에 따라서 배열의 타입도 달라진다.
ㄴ문자를 ASCII기반으로 각 문자들에 대응하는 정수형태로 배열에 저장됩니다.
ㄴ그리고 항상 문자열 마지막에는 문자열의 끝을 표시해주는 0 = NULL이 들어간다.
ㄴ그럼 NULL이 왜 들어가느냐하면 문자열이 출력되다가 NULL값을 만나면 그 이후에 빈칸들은 출력되지 않게하기위해

*이걸 확인해보고싶으면 문자열 출력을 각각의 인덱스를 호출해서 출력해보자!

※빈칸과 null은 엄연히 다르다!(ASCII에서도 각각에 대응하는 정수가 있음)

=========================================

#strlen(문자열의 길이를 알려주는 함수)

-#include <string.h>
ㄴstrlen()함수를 쓸수있도록 해주는 헤더파일
ㄴ이외에도 여러가지 문자열관련 기능들이 들어있음

=========================================

#기호적 상수(Symbolic Constants)와 전처리기 #define

원주율같이 특정 숫자를 계속해서 코드에 복붙하며 사용하면 코드도 지저분해지고 숫자를 틀리게 넣을 수 있기에
이것을 기호로 정의해준다면 해당 기호만 사용하면 끝이여서 코드도 깔끔해지고 실수할일이 줄어든다.

ex) #define PI 3.141592f
ㄴ이것 처럼 원주율을 'PI'라는 기호로 define해주면 앞으로는
계속 PI만 사용하면 된다. 이것을 기호적 상수라 한다.

※컴파일러 입장에서는 우리가 3.141592f를 PI로 교체한 부분을 다시 3.141592f로 바꿔서 컴파일한다!
ㄴ#define은 사용자의 편의를 위해 제공되는 기능이다.
ㄴ#define할때 #define PI '=' 3.141592f과 같이 등호를 붙이는 이러면 등호까지 같이 define되기때문에 주의하자!

+그리고 define기능의 장점이 define했던 값이 변하면 일일이 그 값이 대입되었던 부분을 찾아서 바꿀필요없이 define부분만 변경되는 값으로 고치면 끝이다.

+define할 이름을 정할때는 관습적으로 대문자만을 이용하자!(물론 예외의 경우도 있지만 대문자만을 사용하는 것을 지향하자!)

-const
ㄴdefine과 비슷한 기능을 하는 것이다.
ㄴdefine은 헤더파일을 include하는 위치에서 코드를 작성하지만 const는 main문 안에서 보통 작성된다.

※define이던 const던 이 두개의 목적은 변수의 값을 변하지않게 상수로 만들어 준다는데에 있다. (다만, 요즘 추세가 define보다는 const를 사용하는 것을 더 권장하고있다.)

=========================================

#명백한 상수(Manifest Constants)

#define PI 3.141592
ㄴ이건 명확하게 PI가 의미하는 바가 작성되어있다.
ㄴ이걸 menifest constants라한다.

menifest constants를 많이 사용하는 부분이 바로
<limits.h>와 <float.h>이다.
ㄴ각각의 헤더파일안에는 다량의 기호적 상수가 define되어있다.

=========================================

#printf()함수의 변환 지정자(Conversion_Specifiers)

		<printf의 형식>
printf(제어 문자열, 아이템(변수, 상수, 표현식 등등), 아이템2, ...)

int a = 2;
printf("%d + %d = %d", 1, a, 1 + a);

- 아이템에는 1과같은 상수, a처럼 변수, 1 + a와 같은 표현식이 들어갈수있음

- % + 특정 문자 => 형식 지정자
ㄴ형식 지정자중에서 데이터 타입을 어떤 형식으로 출력해줄지 맞춰주는 지정자들을 변환 지정자라고한다.

		  <변환 지정자>

%a = 부동 소수점 수, 16진수, 소문자 표기
%A = %a, 대문자 표기
%c = 한 글자
%d(또는 %i) = 부호가 있는 decimal integer
%e = 부동 소수점 수, 소문자 표기
%E = %e, 대문자 표기
%g = 값에따라서 %e나 %f를 사용, 지수가 -4보다 작거나,
        정밀도보다 크거나, 같을 경우에는 %e사용
        컴퓨터가 알아서 사용함
%G = %g, 대문자 표기
%o = 부호가 없는 octal integer
%p = 포인터
%s = 문자열
%u = 부호가 없는 decimal integer
%x = 부호가 없는 hexa integer, 소문자 표기
%X = %x, 대문자 표기
%% = %기호 출력

=========================================

#변환 지정자의 수식어(Modifiers)

-변환 지정자의 수식어
ㄴ변환 지정자들의 출력옵션을 바꿔주는 수식어

기본형 -> %[flags][width][.precision][length]specifier
printf("%-10.5hi", 256); 요런 느낌

%+10.5hi
- = 왼쪽 정렬
10 = 10자리 출력
.5 = 소수점 5자리까지
h = short
i = integer

-flag
ㄴ사전적 의미는 깃발인데 컴퓨팅에서는 어떤 형식으로 할건지 앞에 깃발을 달아주는 것 정도로 이해하면 될듯하다.

- = 왼쪽 정렬 출력
+ = 숫자가 양수면 +, 음수면 - 기호를 붙여주는 옵션
빈칸 = 양수일때 +부호 없이 출력해주는 옵션
# = 8진수, 16진수 출력할때 앞에 붙는 0 혹은 0x를 출력하는 옵션
0 = width를 지정했을때 남는 자리를 0으로 채워주는 옵션

-width
ㄴ출력하려는 수의 자리수를 지정해줌

숫자 = 출력하는 수의 출력칸을 지정해줌
ㄴwidth를 5로하고123을 출력한다하면 _ _ 1 2 3이런 식으로 출력
물론, '_'이게 출력되진않고 빈칸으로 출력된다.
* = 이건 아이템을 2개를 입력하는데 먼저 입력된 아이템이 *의 자리로 감
ㄴprintf("%*i", 7, 456);이라는 코드가 있으면, 7이 *자리로 가서 사실상 printf("%7i", 456);이라는 코드가되고 이는 _ _ _ _ 4 5 6이 출력되도록 한다.

-.precision
ㄴ숫자의 정밀도를 지정해주는 옵션, 소수점아래 몇번째까지 출력할지를 정하는 옵션이다.

.숫자 = 숫자 자리수만큼 출력됨(정밀도 보장), 다만 소수점이 없는 수에서는 숫자앞에 부족한 자리수만큼 0으로 채워짐
※소수점아래 .숫자만큼의 자리에서 반올림됨
ex) printf("%.3f", 123456.1235); -> 123456.124 처럼 반올림됨

.* = 예제코드에서 이해할것

-length
ㄴ데이터 타입의 길이