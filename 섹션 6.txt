#while반복문에서 scanf()의 반환값 사용하기

-덧셈 계산기 만들기
ㄴ while문과 scanf문을 이용하여 덧셈 계산기를 만들어보자

-비교 연산자(equality operator)
ㄴ '==' 이렇게 생겼다.
ㄴ 양쪽의 값이 서로 같은지를 비교해주는 연산자이다.

-필요한 변수
1. 입력한 수를 저장할 변수 num
2. 입력받은 수들의 합을 저장할 변수 sum 

-필요한 계산
1. 수들을 입력받는다 scanf()
2. 입력받은 수를 num에 저장하고 sum이랑 더한다.
3. 위 과정을 while문을 사용하여 반복하고
4. 조건은 num에 q가 입력되면 sum값을 출력하고 프로그램을 종료하도록 한다.

-문제점
1. 값을 입력받고 덧셈까지는 정상적으로 실행되지만 q를 입력받고 반복문을 종료하고 sum을 출력해야하는데 q를 입력하는 부분이 잘되지 않았음

-수정사항
1. scanf에서 정수가 정상적으로 입력받았는지를 알기위해 scanf의 반환값을 이용한 'status'변수를 추가
2. scanf는 반환값으로 정상적으로 입력받은 값의 ‘개수’를 돌려주기때문에 while문에 status == 1이라는 조건(사용자가 정수를 1개씩 입력하기때문에 1을 사용하였다.)을 사용하여 정상적인 값이 들어올때는 1이 유지되어 반복이 되지만 문자인 q를 입력하면 정상적으로 입력받은 값이 0개이므로 status가 0이된다 따라서 while문이 종료되고 sum이 출력되면서 프로그램이 종료된다.

-개선사항
ㄴ코드에서 scanf를 사용하는 부분이 2개가 있는데 이를 1개로 줄이는 코드로 수정을 해보자
ㄴwhile문의 괄호안에 scanf문을 삽입하면 status변수와 1개의 scanf문이 필요가 없어진다.

===================================================================================================

#의사코드(Pseudocode)

-수도코드의 사용목적
ㄴ 코드를 작성하기전에 먼저 그 프로그램의 논리 자체에 집중해서 유사코드를 짜보는 것
ㄴ 수도코드는 프로그래밍 언어의 제약없이 작성이 가능하다.
ㄴ 그리고 별도의 정해진 문법은 없으므로 주변사람들이 읽고 이해할 정도의 논리를 나타내면 된다.

☝️프로그램의 설계도를 만든다고 생각하면 쉬울듯하다.

ex)

	[c언어 코드]						[수도코드]
int num, sum = 0;					sum을 0으로 초기화한다.

printf("Enter an integer (q to quit) : ");		사용자에게 안내한다.

while(scanf("%d", &num) == 1)				사용자에게 입력을 받고 그 입력이 정수일 동안에는
{
	sum = sum + num;						그 입력을 sum에 더한다.
	
	printf("Enter next integer (q to quit) : ");		사용자에게 다음번 입력을 받는다.
}

printf("Sum = %d\n", sum);				sum을 출력한다.

===================================================================================================

#관계 연산자(Relational Operators)

-관계 연산자의 종류(연산자의 좌측이 기준이다)
1. <  오른쪽보다 작다
2. <= 오른쪽보다 작거나 같다
3. == 오른쪽과 같다
4. >= 오른쪽보다 크거나 같다
5. >  오른쪽보다 크다
6. != 오른쪽과 같지않다.

-fabs()
ㄴ 실수끼리 관계 연산자를 이용하여 연산을 할때는 fabs를 사용하면 편리하다.
ㄴ fabs()는 ()안의 값의 절댓값을 리턴해주는 함수이다.
ㄴ 실수끼리의 자잘한 소수점 아래 수들을 무시할때 사용할 수 있다.

===================================================================================================

#사실과 거짓

-관계식은 값을 가진다.
ㄴ 프로그래밍에서 보통 1은 ture, 0은 false를 의미한다.
ㄴ 그래서 관계식을 사용해 연산을 진행하면 1 또는 0을 리턴값으로 돌려준다.

⚠️c언어에서는 1이면 참, 0이면 거짓이라고 판단하기 보다는 0이면 거짓, 0이 아니면 참 이렇게 판단을 한다.

☝️그래서 while문 괄호안에 1을 넣으면 무한루프로 만들 수 있다.

===================================================================================================

#'_Bool' 자료형

-_Bool 자료형
ㄴ C99에서 추가된 자료형이다.
ㄴ 기존에 사용되던 bool자료형과의 충돌을 피하고자 _Bool이라는 이름으로 사용하게됨
ㄴ boolean자료도 내부적으론 '정수'로 처리된다. 다만, _Bool이라는 자료형으로 사용함

-#include <stdbool.h>
ㄴ 사용자가 임의로 bool자료형을 만들어 쓸수있는 헤더파일

===================================================================================================

#관계 연산자의 우선순위

-우선순위를 일일이 알고있어야 하는가?
ㄴ 연산자들의 카테고리가 있는데 각 카테고리마다 우선순위가 다르다.
그럼 연산자를 사용할때 각각의 우선순위를 알고있어야하냐 라고하면 그건 또 아니다
우선순위가 제일 높은 '()'를 이용해서 각각의 연산자들의 연산 순서를 정해줄 수 있기때문이다.

☝️불가피하게 연산자 간에 우선순위를 알아야 한다면 구글링을 통해 쉽게 찾을 수 있다.

===================================================================================================

#for 반복문

-while문의 단점
ㄴ while문은 반복문의 반복 횟수를 정해주는 카운터 기능이 필요함으로 while문을 사용하려면 카운터변수 선언 및 초기화, 카운터 체크, 카운팅 기능이 필요하다.
ㄴ 근데 이중에 한부분이 잘못된다면 while문이 무한루프가된다거나 유저가 원하는 방향으로 작동하지 않을것이다.
ㄴ 그리고 근본적으로 while문은 indefinite loop이기때문이다.

-for문의 기본 구성


		for(int i = 1; i <= 10; i++)
		{
			//do something
		}

ㄴ 이런식으로 사용하면된다. while문의 카운터와 관련된 부분을 for문은 ()안에다 작성하면된다.

☝️while문으로 만들 수 있는것은 for문으로도 할 수 있고, 반대로 for문으로 가능한것은 while문으로도 가능하다!

===================================================================================================

#for 반복문의 유연성

-for문의 유연성
ㄴ 앞서 설명했던 for문의 ()안에는 카운터 선언 및 초기화, 카운터 체크, 카운팅의 기능이 들어간다.
ㄴ 근데 이 부분을 좀 더 창의적으로 추가적인 연산식을 넣어서 작성이 가능하며, 문자도 넣어서 연산을 할 수 있다.
ㄴ 심지어 카운터 선언 및 초기화에서 여러개의 카운터 변수를 선언하고 초기화 가능하다. 다만, 같은 자료형에 한해서 가능하다.

===================================================================================================

#다양한 대입 연산자

-대입 연산자의 종류
1. +=
2. -=
3. *=
4. /=
5. %/

☝️대입 연산자는 연산자의 우선순위에서 거의 마지막이다.

-어셈블리 언어 확인해보기
ㄴ 자신이 작성한 코드의 어셈블리를 확인해보고 같은 기능을 수행하더라도 어떤 방식이 좀 더 최적화되어있는지 확인해보자

===================================================================================================

#콤마(comma) 연산자

-콤마(,)의 기능

1. 한개의 expression에서 두개이상의 기능을 넣기위해 사용된다.
  ㄴ 예를들면 int형 변수i와 변수j를 선언할때 따로따로 선언하는것이 아닌 int i, j;로 선언한다.
  ㄴ 물론 같은 자료형에 한해서 사용가능하다.

2. 그리고 또 다른 기능은 우리가 알고있는 구분(seperator)의 기능을 수행한다.
  ㄴ printf("%d %d\n", i, j);와 같이 각각의 부분을 구분지어줌

3. sequence point
  ㄴ ';'이 그 문장의 끝을 의미한다 즉 연산을 ;까지 진행하라는 것인데 ','역시 이 표시로 사용된다.
  ㄴ 그래서 우리가 앞서 배웠던 선위 증가 연산자, 후위 증가 연산자와 ','를 같이 사용할때 주의 해야된다.

===================================================================================================

#제논의 역설 시뮬레이션

-제논의 역설
ㄴ 아킬레스가 거북이와 경주를 하는데, 거북이는 100m앞에서 출발하지만, 아킬레스는 거북이보다 10배 빠르다.
ㄴ 아칼레스가 100m 달리면, 거북이는 10m 앞에 가 있다, 아칼레스가 10m더 달리면, 거북이는 1m 앞에 있다.
ㄴ 이와 같이 간격은 끝없이 줄일 수 있지만, 결코 사라지지 않는다 그래서 아킬레스는 거북이를 평생 따라잡을 수 없다는 것이 제논의 역설이다.

ㄴ 하지만 무한등비급수를 이용하면 역설이 틀렸다는 것을 수학적으로 증명할 수 있다.

===================================================================================================

#탈출조건 루프 do while

-do while
ㄴ 반복문을 실행하기전에 반복하는 루틴을 무조건 1번은 실행이 되야할때 사용한다.

	do
	{
		printf("Enter secret code : ");
		scanf("%d", &guess);
	}
	while (guess != secret_code);

ㄴ 이런식으로 사용하면 된다. 비밀번호를 맞출때까지 반복되는 코드인데 반복문에 진입하기 전에 먼저 입력을 받고 조건에 맞춰보는 루틴이 먼저 실행된다.
ㄴ 비밀번호가 일치하면 반복문에 진입하지 않고 지나가지만 그렇지않다면 반복문으로 진입하게된다.

☝️ 지금까지 우리는 for, while, do while 이렇게 3가지의 반복문을 배웠다, 이세가지 모두 같은 기능을 수행할 수 있으나 상황에 맞춰 좀더 적합한 반복문을 채용하자

===================================================================================================

#어떤 루프를 사용할까?

-진입조건 vs 탈출조건
ㄴ 진입조건 루프에는 while, for, 탈출조건 루프에는 do while이 있다.

-어떨때 어떤 루프가 적합할까?
ㄴ for문은 정해진 횟수가 있는 반복일때 사용하는 것이 적합하다
ㄴ while문은 횟수를 예상하디 어려운 반복을 해야할때 적합하다
ㄴ do while문은 일단 한번은 루틴이 실행되어야할때 적합하다

✓실무나 왠만한 반복기능을 구현할때는 for문이 주로 쓰인다.
❗️모든 반복문은 서로 호환이 가능하다 그렇기에 꼭 어떤 반복문이 좋더라는 없다.
⚠️ 문법은 많이 알고있으면 좋으면 좋지 나쁘지는 않기에 숙지하자!

===================================================================================================

#중첩된(Nested) 루프들

-다중 반복문
ㄴ 반복문안에 반복문을 넣을 수 있다.
ㄴ 반복문이 중첩되는 개수의 제한은 없다.
ㄴ 다중 반복문의 특징이라면 반복문에 사용되는 변수를 조건문에 공유할 수 있다는 것이다.

ex)
 for (r = 0; r < NUM_ROWS; ++r)
    {
        for (c = FIRST_CHAR + r; c <= LAST_CHAR; ++c)
        {
            printf("%c ", c);
        }
        printf("\n");
    }
ㄴ 이런 방식으로 사용된다.

===================================================================================================

#배열(Array)과 런타임(Runtime) 에러

-배열(Array)
ㄴ 배열은 같은 자료형의 메모리공간을 '연속적'으로 할당받는 것을 의미한다.
ㄴ ㅁ <- 메모리 공간이라고 할때 ㅁㅁㅁㅁㅁ <- 이것이 배열인 것이다.
ㄴ 그래서 배열에 문자, 숫자 등을 넣어서 저장할 수 있다.

-배열 선언은 int arr[5]; 이렇게 선언하면 된다.
ㄴ 배열의 자료형, 배열 이름, 원하는 크기 순으로 작성하면 된다.
ㄴ 배열의 첫번째 칸의 주소값은 1이 아닌 0이다.
☝️첫번째 주소값이 0이어야 이후의 주소값들은 첫번째 주소로부터 몇칸 떨어져있는지를 토대로 주소값을 지정해주기 때문이다.
ㄴ 이 값은 'index'라고 부른다. 이외에도 subscript, offset이라고도 함

✓scanf에서 입력받은 값을 배열에 넣을때 변수앞에 '&'를 붙이는데 배열의 이름을 넣고 입력을 받을때는 이미 배열의 주소도 포함되어 있기에 '&'를 붙일 필요 없다
ㄴ scanf("%d", &my_numbers[0]); = scanf("%d", my_numbers);

-runtime error
ㄴ compile error와는 다른 오류이다.
ㄴ compile error는 문법오류가 나면 생기는 문제인 반면에, runtime error는 컴파일에서는 문제가 없지만 막상 프로그램이 실행되면 문제가 생기는 것을 의미한다.
ㄴ compile error보다는 찾기 힘든 오류지만 디버거를 사용하면 문제가 되는 부분을 금방 찾을 수 있다.

ex)
	int my_numbers[5];

1번예시)	my_numbers[5] = 123;    // out of bound

2번예시)	my_numbers = 7;       // compile error

3번예시)	printf("%d\n", my_numbers[5]);// out of bound

보통 위 3가지 실수를 하게되면 런타임 에러가 생긴다, 런타임 에러는 컴파일러가 잡아주지 않고 프로그램이 실행될때서야 runtime에러가 발생했다고 알려준다.

1번예시에서는 선언한 배열의 범위를 넘어서는 인덱스 값을 사용해서 문제이다. 0번부터 4번까지 총 5개인데 5를 사용하면서 범위를 넘어섰다.

2번예시에서는 배열을 선언하고나서 배열의 어떤 칸에 값을 넣을지를 표기하지 않아 문제가 발생했다. 배열이름[인덱스값] = 7; 이런 식으로 사용해야한다.

3번예시에서는 1번과 동일한 문제이다. 선언했던 배열의 범위를 넘어서는 인덱스값을 넣었기에 문제가 발생했다. n개짜리 배열을 선언하면 그 배열의 마지막 인덱스값은 n-1임을 꼭 기억하자!

===================================================================================================

#for루프를 배열과 함께 사용하기

-for문과 배열
ㄴ 앞선 강의에서 배열을 선언하고 인덱스값을 이용해서 배열의 각각의 메모리공간에 접근하는 방법도 배웠는데
ㄴ 배열에 소속된 메모리공간들을 일일이 접근해서 값을 넣는다는 것은 매우 불편하다
ㄴ 그래서 반복문을 이용해서 자동으로 배열 하나하나에 접근하고 값을 넣는 방식을 사용하는 것이 편리하다.

ex)
int my_array[5];

for (int i = 0; i < 5; ++i)
	my_arr[i] = i;

ㄴ반복문의 카운터기능을 하는 변수 i를 이용해서 배열 각각의 메모리 공간에 접근하고 값을 넣는다.

☝️이를 이용해서 숫자 5개를 입력받고 그걸 배열에 저장하고 다 더한 값과 평균값을 출력해보자
ㄴ for문, 배열, scanf 등을 이용해서 사용할것

✓최근 컴퓨팅에서는 하드웨어의 발달로 코드를 줄이는 것보다는 코드의 양이 늘어나더라도 가독성의 향샹과 유지보수가 쉬운쪽으로 코딩을 한다. 왜냐하면, 처리해야하는 데이터의 양이 매우 많아졌기때문이다.

===================================================================================================

#루프안에서 함수의 반환값 사용하기

-함수를 만들어서 사용하기
ㄴ 앞선 강의에서 main함수이외에 다른 함수를 만들어서 main문에서 해당 함수를 호출해서 사용하는 방식을 배웠을텐데 그것을 사용해보자
ㄴ 이번 강의에서는 사용자가 입력하는 2개의 값을 이용해서 A값의 B제곱 값을 출력하는 코드를 만들어보는 것이다.

ㄴ 코드를 작성해보면 반복문안에 적지않은 양의 연산코드를 작성될것이다.
ㄴ 그럼 main문이 너무 길어지고 복잡해진다.
ㄴ 실무에서는 훨씬 더 많은 양의 코드들이 복잡하게 연결되어 있을텐데 그 많은 것들을 main문안에 넣어둔다면 어떻겠는가?
ㄴ 그래서 main문에서는 기능을 수행하는 각각의 함수들을 호출해서 시스템을 굴린다.

ㄴ 그래서 이번에는 main문 밖에 함수를 선언하고 그 함수를 main문에서 호출해서 반환값을 이용해보도록 하자

-입력받은 2개의 값을 제곱값으로 반환해주는 함수

	int compute_pow(int base, int exp)
	{
    		int i, result;
    
    		result = 1;
    		for (i = 0; i < exp; ++i)
   		{
        			result *= base;
    		}
    
    		return result;
	}

☝️base = 사용자에게 입력받은 1번 정수, exp = 사용자에게 입력받은 base를 몇번 제곱할건지를 위한 수
ㄴ 위 변수값은 main문에서 사용자가 이미 입력했음

-함수 선언하는 부분 : 이 함수를 시용하기위한 input은 사용자에게 입력받은 2개의 정수이니 int, 그리고 함수 이름을 쓰고, 어떤 값을 input으로 넣는지 작성한다

-변수 선언하는 부분 : 함수안에서 사용할 필요한 변수들을 선언, 여기서는 반복문 카운팅 변수i, 제곱값을 저장할 변수result 선언
		ㄴ 그리고 result는 1로 초기화

-반복문 부분 : main문에서 입력받은 정수 2개를 반복문을 이용해서 base를 exp만큼 계속 곱하고 그 값을 곱할때마다 result에 저장

-반환하는 부분 : main문에서는 return 0;를 하므로써 프로그램이 정상적으로 실행됐다는 반환값으로 0을 반환하지만 위 함수는 제곱값을 반환해야하므로 return result;를 하여 main문으로 result값을 돌려준다.

⚠️ 이런방식으로 앞으로 코드를 작성하다보면 변수의 이름이 겹치는 순간이 자주온다. 분면 변수의 이름은 유일해야하는데 겹친다니 헷갈릴것이지만 우리가 코드를 작성할때 '{}'안에다가 코드를 작성한다, {}의 의미는 영역을 구분지어주는 것인데 main문이던 다른 함수던 반복문이던 {}안에서 선언된 변수는 해당 함수의 {}안에서만 유효하다 즉, main문 밖에있는 함수의 변수 i와, main문 안에서의 변수i는 완전히 다른 변수i인 것이다.